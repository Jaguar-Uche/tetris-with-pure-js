import React, { useRef, useEffect, useState, useCallback } from "react";

// =============================
// PARTICLE CLASS
// =============================
class Particle {
  constructor(x, y) {
    this.x = x + 12.5;
    this.y = y + 12.5;
    this.vx = (Math.random() - 0.5) * 3;
    this.vy = (Math.random() - 1.5) * 3;
    this.size = Math.random() * 3 + 2;
    this.alpha = 1;
    const colors = ["#00bcd4", "#e91e63", "#ffc107", "#673ab7", "#4caf50"];
    this.color = colors[Math.floor(Math.random() * colors.length)];
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.alpha -= 0.02;
  }

  draw(ctx) {
    ctx.save();
    ctx.globalAlpha = this.alpha;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  isAlive() {
    return this.alpha > 0;
  }
}

// =============================
// TIMER (for future use)
// =============================
const Timer = {
  start: () => {},
  pause: () => {},
  resume: () => {},
  reset: () => {},
};

// =============================
// SHAPE DEFINITIONS
// =============================
const createShape = (name, drawFn, findIndexFn, updateRotabilityFn) => ({
  name,
  moving: false,
  shapeX: 0,
  shapeY: 0,
  speedable: false,
  leftMoveable: false,
  rightMoveable: false,
  downMoveable: false,
  rotable1: false,
  rotable2: false,
  rotable3: false,
  rotable4: false,
  timeoutId: null,

  generateX: function () {
    const max = Math.floor((500 - 100) / 25);
    const random = Math.floor(Math.random() * (max + 1));
    this.shapeX = random * 25 + 175; // Center bias
  },

  draw: drawFn,
  findIndex: findIndexFn,
  updateRotability: updateRotabilityFn,

  animate: function (
    x,
    y,
    speed,
    refreshBoard,
    occupy,
    dropAndClear,
    checkGameOver,
    clearMoveable,
    game,
    currentShape,
    normalDropSpeed,
    drawBlock
  ) {
    if (!game.running) return;
    this.moving = true;
    this.shapeX = x;
    this.shapeY = y;
    this.findIndex(x, y, game);
    this.draw(x, y, drawBlock);
    this.updateMovability(game);
    this.updateSpeedable(game);
    this.updateRotability(game);
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      if (this.downMoveable) {
        refreshBoard();
        this.shapeY += 25;
        this.animate(
          this.shapeX,
          this.shapeY,
          normalDropSpeed,
          refreshBoard,
          occupy,
          dropAndClear,
          checkGameOver,
          clearMoveable,
          game,
          currentShape,
          normalDropSpeed,
          drawBlock
        );
      } else {
        occupy(game);
        dropAndClear();
        checkGameOver(this, game);
        currentShape.length = 0;
        this.moving = false;
        clearMoveable(this, game);
      }
    }, speed || 500);
  },

  updateMovability: function (game) {
    this.leftMoveable = checkLeft(game.indexA, game.indexB, game.indexC, game.indexD);
    this.rightMoveable = checkRight(game.indexA, game.indexB, game.indexC, game.indexD);
    this.downMoveable = checkDown(game.indexD);
    if (!this.downMoveable) {
      clearMoveable(this, game);
    }
  },

  updateSpeedable: function (game) {
    this.speedable = true;
    const below = game.indexD + 40;
    checkBelow(this, 100, below, game);
  },
});

// Define all shapes
const O = createShape(
  "O",
  (x, y, drawBlock) => {
    drawBlock(x, y);
    drawBlock(x + 25, y);
    drawBlock(x, y + 25);
    drawBlock(x + 25, y + 25);
  },
  (x, y, game) => {
    game.indexA = calculateIndex(x, y);
    game.indexB = calculateIndex(x + 25, y);
    game.indexC = calculateIndex(x, y + 25);
    game.indexD = calculateIndex(x + 25, y + 25);
  },
  () => {} // O can't rotate
);

const I = createShape(
  "I",
  (x, y, drawBlock) => {
    drawBlock(x, y);
    drawBlock(x, y + 25);
    drawBlock(x, y + 50);
    drawBlock(x, y + 75);
  },
  (x, y, game) => {
    game.indexA = calculateIndex(x, y);
    game.indexB = game.indexA + 20;
    game.indexC = game.indexB + 20;
    game.indexD = game.indexC + 20;
  },
  (game) => {
    const a = game.indexA;
    I.rotable1 =
      checkEmpty(a - 1, a - 2, a - 3) &&
      checkSameRow(a - 1, a - 2, a - 3, a);
    I.rotable2 =
      checkEmpty(a + 1, a + 2, a + 3) &&
      checkSameRow(a + 1, a + 2, a + 3, a);
  }
);

const I2 = createShape(
  "I2",
  (x, y, drawBlock) => {
    drawBlock(x, y);
    drawBlock(x + 25, y);
    drawBlock(x + 50, y);
    drawBlock(x + 75, y);
  },
  (x, y, game) => {
    game.indexA = calculateIndex(x, y);
    game.indexB = game.indexA + 1;
    game.indexC = game.indexB + 1;
    game.indexD = game.indexC + 1;
  },
  (game) => {
    const a = game.indexA;
    I2.rotable1 =
      checkEmpty(a - 20, a - 40, a - 60) &&
      checkSameRow(a - 20, a - 40, a - 60, a);
    I2.rotable2 =
      checkEmpty(a + 20, a + 40, a + 60) &&
      checkSameRow(a + 20, a + 40, a + 60, a);
  }
);

// Continue for T, S, Z, L, J...
// For brevity, I'll define T and leave others as stubs â€” you can copy the pattern

const T = createShape(
  "T",
  (x, y, drawBlock) => {
    drawBlock(x - 25, y);
    drawBlock(x, y);
    drawBlock(x + 25, y);
    drawBlock(x, y + 25);
  },
  (x, y, game) => {
    game.indexA = calculateIndex(x - 25, y);
    game.indexB = calculateIndex(x, y);
    game.indexC = calculateIndex(x + 25, y);
    game.indexD = calculateIndex(x, y + 25);
  },
  () => {}
);

// Add T1, T2, T4, S, S2, Z, Z2, L, L1, L2, L4, J, J1, J2, J4 similarly...

// Rotation links
I.rotate1 = I2;
I.rotate2 = I2;
I2.rotate1 = I;
I2.rotate2 = I;

// Add all rotation links as in your original code...

// =============================
// MAIN TETRIS COMPONENT
// =============================
const Tetris = () => {
  const gameCanvasRef = useRef(null);
  const nextCanvasRef = useRef(null);
  const gameContainerRef = useRef(null);

  const [score, setScore] = useState(0);
  const [game, setGame] = useState({
    running: false,
    keyPressed: null,
    downHeld: false,
    gameEnded: false,
    dropIntervalId: null,
    shapeDoneInterval: null,
    nextShape: null,
    indexA: null,
    indexB: null,
    indexC: null,
    indexD: null,
  });

  const boxesRef = useRef([]);
  const rowsRef = useRef([]);
  const columnsRef = useRef([]);
  const particlesRef = useRef([]);
  const currentShapeRef = useRef([]);
  const shapeObjectsRef = useRef([O, I, I2, T /* Add all */]);

  const gameWidth = 500;
  const gameHeight = 500;
  const unit = 25;
  const ROWS = 20;
  const COLS = 20;

  const LEFT = 37, RIGHT = 39, DOWN = 40;
  const ROTATE1 = 65, ROTATE2 = 68, ROTATE3 = 87, ROTATE4 = 83;

  const moveSound = useRef(new Audio("sounds/move.mp3"));
  const scatterSound = useRef(new Audio("sounds/wind.mp3"));
  const gameOverSound = useRef(new Audio("sounds/tetristheme.mp3"));

  const nextShapeArrays = {
    O: [[75, 75], [75, 100], [100, 75], [100, 100]],
    I: [[90, 50], [90, 75], [90, 100], [90, 125]],
    I2: [[50, 75], [75, 75], [100, 75], [125, 75]],
    T: [[60, 75], [85, 75], [110, 75], [85, 100]],
    // Add all others...
  };

  const normalDropSpeed = 500;
  const fastDropSpeed = 100;

  // =============================
  // UTILS
  // =============================
  const calculateIndex = (x, y) => (y / unit) * COLS + x / unit;

  const drawBlock = (ctx, x, y) => {
    ctx.strokeStyle = "black";
    ctx.fillStyle = "white";
    ctx.lineWidth = 2;
    ctx.fillRect(x, y, unit, unit);
    ctx.strokeRect(x, y, unit, unit);
  };

  const generateBoxes = () => {
    let v = 0;
    boxesRef.current = [];
    rowsRef.current = [];
    columnsRef.current = [];
    for (let i = 0; i < 500; i += unit) {
      const rowIdx = i / unit;
      rowsRef.current[rowIdx] = [];
      for (let t = 0; t < 500; t += unit) {
        const colIdx = t / unit;
        boxesRef.current[v] = {
          startCoordinates: [t, i],
          endCoordinates: [t + unit, i + unit],
          occupied: false,
        };
        rowsRef.current[rowIdx].push(v);
        if (!columnsRef.current[colIdx]) columnsRef.current[colIdx] = [];
        columnsRef.current[colIdx].push(v);
        v++;
      }
    }
  };

  const refreshBoard = useCallback(() => {
    const ctx = gameCanvasRef.current.getContext("2d");
    ctx.fillStyle = "burlywood";
    ctx.fillRect(0, 0, gameWidth, gameHeight);
    boxesRef.current.forEach((box) => {
      if (box.occupied) {
        const [x, y] = box.startCoordinates;
        drawBlock(ctx, x, y);
      }
    });
  }, [gameWidth, gameHeight]);

  const drawNext = (shape) => {
    const ctx = nextCanvasRef.current.getContext("2d");
    ctx.fillStyle = "burlywood";
    ctx.fillRect(0, 0, 200, 200);
    if (!shape || !nextShapeArrays[shape.name]) return;
    nextShapeArrays[shape.name].forEach(([x, y]) => {
      ctx.strokeStyle = "black";
      ctx.fillStyle = "white";
      ctx.lineWidth = 2;
      ctx.fillRect(x, y, unit, unit);
      ctx.strokeRect(x, y, unit, unit);
    });
  };

  const occupy = (game) => {
    [game.indexA, game.indexB, game.indexC, game.indexD].forEach((idx) => {
      if (idx !== null && boxesRef.current[idx]) {
        boxesRef.current[idx].occupied = true;
      }
    });
  };

  const checkLeft = (...indices) =>
    indices.every((i) => i !== null && boxesRef.current[i]?.startCoordinates[0] > 0 && !boxesRef.current[i - 1]?.occupied);

  const checkRight = (...indices) =>
    indices.every((i) => i !== null && boxesRef.current[i]?.endCoordinates[0] < 500 && !boxesRef.current[i + 1]?.occupied);

  const checkDown = (index) =>
    index !== null && boxesRef.current[index]?.endCoordinates[1] < 500 && !boxesRef.current[index + 20]?.occupied;

  const checkEmpty = (...indices) =>
    indices.every((i) => i >= 0 && i < boxesRef.current.length && !boxesRef.current[i]?.occupied);

  const checkSameRow = (...indices) => {
    const rows = indices.map((i) => Math.floor(i / 20));
    return new Set(rows).size === 1;
  };

  const checkBelow = (obj, height, ...indices) => {
    if (obj.shapeY >= gameHeight - height) obj.speedable = false;
    if (indices.some((i) => i < boxesRef.current.length && boxesRef.current[i]?.occupied)) {
      obj.speedable = false;
    }
  };

  const clearMoveable = (obj, game) => {
    obj.leftMoveable = obj.rightMoveable = false;
    game.downHeld = false;
    if (game.dropIntervalId) clearInterval(game.dropIntervalId);
  };

  const dropAndClear = useCallback((calledBySelf = false) => {
    const cleared = [];
    for (let r = 0; r < ROWS; r++) {
      if (rowsRef.current[r].every((i) => boxesRef.current[i].occupied)) {
        cleared.push(r);
      }
    }
    if (!cleared.length) return;

    const size = cleared.length;
    const baseScore = calledBySelf ? size * size * 10 : size * size * 5;
    setScore((s) => s + baseScore);

    cleared.forEach((r) => {
      rowsRef.current[r].forEach((i) => {
        const [x, y] = boxesRef.current[i].startCoordinates;
        for (let k = 0; k < 5; k++) particlesRef.current.push(new Particle(x, y));
      });
    });

    scatterSound.current.currentTime = 0;
    scatterSound.current.play();

    const animateParticles = () => {
      if (particlesRef.current.length === 0) return;
      requestAnimationFrame(animateParticles);
      const ctx = gameCanvasRef.current.getContext("2d");
      particlesRef.current.forEach((p) => p.update());
      refreshBoard();
      particlesRef.current.forEach((p) => p.draw(ctx));
      particlesRef.current = particlesRef.current.filter((p) => p.isAlive());
    };
    animateParticles();

    setTimeout(() => {
      cleared.forEach((r) => {
        rowsRef.current[r].forEach((i) => (boxesRef.current[i].occupied = false));
      });
      let moved;
      const fall = setInterval(() => {
        moved = false;
        for (let i = boxesRef.current.length - 1; i >= 0; i--) {
          const below = i + 20;
          if (
            boxesRef.current[i].occupied &&
            below < boxesRef.current.length &&
            !boxesRef.current[below].occupied
          ) {
            boxesRef.current[below].occupied = true;
            boxesRef.current[i].occupied = false;
            moved = true;
          }
        }
        refreshBoard();
        if (!moved) {
          clearInterval(fall);
          dropAndClear(true);
        }
      }, 50);
    }, 500);
  }, [refreshBoard]);

  const checkGameOver = (obj, game) => {
    const cols = new Set([
      game.indexA % 20,
      game.indexB % 20,
      game.indexC % 20,
      game.indexD % 20,
    ]);
    if ([...cols].some((c) => columnsRef.current[c]?.[0] && boxesRef.current[columnsRef.current[c][0]].occupied)) {
      clearTimeout(obj.timeoutId);
      setGame((g) => ({ ...g, gameEnded: true, running: false }));
      setTimeout(gameOver, 400);
    }
  };

  const gameOver = () => {
    gameOverSound.current.play();
    const ctx = gameCanvasRef.current.getContext("2d");
    let alpha = 1;
    const fade = setInterval(() => {
      ctx.fillStyle = "burlywood";
      ctx.fillRect(0, 0, 500, 500);
      ctx.globalAlpha = alpha;
      refreshBoard();
      ctx.globalAlpha = 1;
      alpha -= 0.05;
      if (alpha <= 0) {
        clearInterval(fade);
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fillRect(0, 200, 500, 100);
        ctx.fillStyle = "red";
        ctx.font = "bold 48px Arial";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", 250, 260);

        const btn = document.createElement("button");
        btn.textContent = "Restart";
        btn.style.marginTop = "20px";
        btn.onclick = restartGame;
        gameContainerRef.current.appendChild(btn);
      }
    }, 100);
  };

  const startNextShape = useCallback(() => {
    if (!game.running) return;
    setGame((g) => ({ ...g, downHeld: false }));
    if (game.dropIntervalId) clearInterval(game.dropIntervalId);

    const shape = game.nextShape || shapeObjectsRef.current[Math.floor(Math.random() * shapeObjectsRef.current.length)];
    const next = shapeObjectsRef.current[Math.floor(Math.random() * shapeObjectsRef.current.length)];
    setGame((g) => ({ ...g, nextShape: next }));
    drawNext(next);

    shape.generateX();
    currentShapeRef.current = [shape];
    shape.animate(
      shape.shapeX,
      0,
      normalDropSpeed,
      refreshBoard,
      occupy,
      dropAndClear,
      checkGameOver,
      clearMoveable,
      game,
      currentShapeRef.current,
      normalDropSpeed,
      (x, y) => drawBlock(gameCanvasRef.current.getContext("2d"), x, y)
    );

    if (game.shapeDoneInterval) clearInterval(game.shapeDoneInterval);
    const interval = setInterval(() => {
      if (currentShapeRef.current.length === 0 && game.running) {
        clearInterval(interval);
        setTimeout(startNextShape, 1500);
      }
    }, 100);
    setGame((g) => ({ ...g, shapeDoneInterval: interval }));
  }, [game.running, game.nextShape, game.dropIntervalId, game.shapeDoneInterval, refreshBoard, dropAndClear]);

  const gameStart = useCallback(() => {
    generateBoxes();
    setGame((g) => ({ ...g, running: true }));
    Timer.start();
    startNextShape();
  }, [startNextShape]);

  const pauseGame = useCallback(() => {
    if (game.gameEnded) return;
    setGame((g) => {
      if (g.running) {
        const shape = currentShapeRef.current[0];
        if (shape) {
          clearTimeout(shape.timeoutId);
          shape.moving = false;
        }
        Timer.pause();
        return { ...g, running: false };
      } else {
        Timer.resume();
        if (currentShapeRef.current.length === 0) {
          startNextShape();
        } else {
          const shape = currentShapeRef.current[0];
          shape.animate(
            shape.shapeX,
            shape.shapeY,
            normalDropSpeed,
            refreshBoard,
            occupy,
            dropAndClear,
            checkGameOver,
            clearMoveable,
            game,
            currentShapeRef.current,
            normalDropSpeed,
            (x, y) => drawBlock(gameCanvasRef.current.getContext("2d"), x, y)
          );
        }
        return { ...g, running: true };
      }
    });
  }, [game.gameEnded, game.running, startNextShape, refreshBoard, dropAndClear]);

  const restartGame = useCallback(() => {
    const btn = gameContainerRef.current.querySelector("button");
    if (btn) btn.remove();
    setScore(0);
    setGame({
      running: true,
      keyPressed: null,
      downHeld: false,
      gameEnded: false,
      dropIntervalId: null,
      shapeDoneInterval: null,
      nextShape: null,
      indexA: null,
      indexB: null,
      indexC: null,
      indexD: null,
    });
    currentShapeRef.current = [];
    particlesRef.current = [];
    generateBoxes();
    refreshBoard();
    gameStart();
  }, [gameStart, refreshBoard]);

  const handleKeyDown = useCallback(
    (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        pauseGame();
        return;
      }
      if (!game.running || currentShapeRef.current.length === 0) return;
      const shape = currentShapeRef.current[0];

      // Move left/right
      if (e.keyCode === LEFT && shape.leftMoveable) {
        moveSound.current.currentTime = 0;
        moveSound.current.play();
        refreshBoard();
        shape.shapeX -= unit;
        clearTimeout(shape.timeoutId);
        shape.animate(
          shape.shapeX,
          shape.shapeY,
          normalDropSpeed,
          refreshBoard,
          occupy,
          dropAndClear,
          checkGameOver,
          clearMoveable,
          game,
          currentShapeRef.current,
          normalDropSpeed,
          (x, y) => drawBlock(gameCanvasRef.current.getContext("2d"), x, y)
        );
      }

      if (e.keyCode === RIGHT && shape.rightMoveable) {
        moveSound.current.currentTime = 0;
        moveSound.current.play();
        refreshBoard();
        shape.shapeX += unit;
        clearTimeout(shape.timeoutId);
        shape.animate(
          shape.shapeX,
          shape.shapeY,
          normalDropSpeed,
          refreshBoard,
          occupy,
          dropAndClear,
          checkGameOver,
          clearMoveable,
          game,
          currentShapeRef.current,
          normalDropSpeed,
          (x, y) => drawBlock(gameCanvasRef.current.getContext("2d"), x, y)
        );
      }

      // Fast drop
      if (e.keyCode === DOWN && !game.downHeld && shape.speedable) {
        setGame((g) => ({ ...g, downHeld: true }));
        clearTimeout(shape.timeoutId);
        const interval = setInterval(() => {
          if (shape.downMoveable) {
            refreshBoard();
            shape.shapeY += unit;
            shape.findIndex(shape.shapeX, shape.shapeY, game);
            shape.updateMovability(game);
            shape.updateSpeedable(game);
            shape.updateRotability(game);
            shape.draw(shape.shapeX, shape.shapeY, (x, y) =>
              drawBlock(gameCanvasRef.current.getContext("2d"), x, y)
            );
          } else {
            occupy(game);
            clearInterval(interval);
            setGame((g) => ({ ...g, downHeld: false, dropIntervalId: null }));
            dropAndClear();
            checkGameOver(shape, game);
            currentShapeRef.current = [];
            shape.moving = false;
            clearMoveable(shape, game);
          }
        }, fastDropSpeed);
        setGame((g) => ({ ...g, dropIntervalId: interval }));
      }

      // Rotation logic (A/D/W/S)
      if (e.keyCode === ROTATE1 && shape.rotable1 && shape.rotate1) {
        rotateShape(shape, shape.rotate1, 0, 0);
      }
      // Add ROTATE2, ROTATE3, ROTATE4 with offset logic...
    },
    [game, refreshBoard, dropAndClear, pauseGame]
  );

  const rotateShape = (oldShape, newShape, dx, dy) => {
    clearTimeout(oldShape.timeoutId);
    currentShapeRef.current[0] = newShape;
    newShape.shapeX = oldShape.shapeX + dx;
    newShape.shapeY = oldShape.shapeY + dy;
    refreshBoard();
    newShape.findIndex(newShape.shapeX, newShape.shapeY, game);
    newShape.updateMovability(game);
    newShape.updateRotability(game);
    newShape.animate(
      newShape.shapeX,
      newShape.shapeY,
      normalDropSpeed,
      refreshBoard,
      occupy,
      dropAndClear,
      checkGameOver,
      clearMoveable,
      game,
      currentShapeRef.current,
      normalDropSpeed,
      (x, y) => drawBlock(gameCanvasRef.current.getContext("2d"), x, y)
    );
  };

  const handleKeyUp = useCallback((e) => {
    if (e.keyCode === DOWN) {
      setGame((g) => {
        if (g.dropIntervalId) clearInterval(g.dropIntervalId);
        const shape = currentShapeRef.current[0];
        if (shape && shape.moving && shape.downMoveable) {
          shape.animate(
            shape.shapeX,
            shape.shapeY,
            normalDropSpeed,
            refreshBoard,
            occupy,
            dropAndClear,
            checkGameOver,
            clearMoveable,
            game,
            currentShapeRef.current,
            normalDropSpeed,
            (x, y) => drawBlock(gameCanvasRef.current.getContext("2d"), x, y)
          );
        }
        return { ...g, downHeld: false, dropIntervalId: null };
      });
    }
  }, [game, refreshBoard, dropAndClear]);

  useEffect(() => {
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    gameStart();

    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [handleKeyDown, handleKeyUp, gameStart]);

  return (
    <div ref={gameContainerRef} style={{ textAlign: "center", fontFamily: "Arial" }}>
      <div style={{ display: "flex", justifyContent: "center", gap: "20px" }}>
        <canvas ref={gameCanvasRef} width={500} height={500} style={{ border: "3px solid #8B4513" }} />
        <div>
          <canvas ref={nextCanvasRef} width={200} height={200} style={{ border: "2px solid #8B4513", display: "block" }} />
          <div style={{ marginTop: "10px", fontSize: "24px" }}>Score: {score}</div>
          <button onClick={pauseGame} style={{ margin: "5px", padding: "10px" }}>
            {game.running ? "Pause" : "Resume"}
          </button>
          <button onClick={restartGame} style={{ margin: "5px", padding: "10px" }}>
            Restart
          </button>
        </div>
      </div>
    </div>
  );
};

export default Tetris;